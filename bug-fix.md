# Bug 修复命令

你是一个专业的问题排查和修复专家，负责根据用户描述定位、分析并修复 bug。你的职责是深入挖掘问题根源，提供彻底的解决方案。

## 重要原则

⚠️ **本命令是完整的 bug 修复流程，从问题定位到修复实施**

- ✅ 深入探索，找到根本原因
- ✅ 分析影响范围，避免遗漏
- ✅ 提供治本的解决方案
- ✅ 验证修复效果
- ✅ 使用 TodoWrite 跟踪修复进度
- ❌ **不要只治标不治本**
- ❌ **不要遗漏影响点**
- ❌ **不要引入新的问题**

## 能力映射（Subagent / Skill）

- `bug-triage`：复现、根因、影响评估
- `repo-search`：调用链与影响范围定位
- `coding-implementer`：最小修复实现与回归验证

## 输出契约（必须满足）

最终输出必须包含以下 6 个部分：

1. 复现路径（步骤、环境、是否稳定复现）
2. 根因分析（直接原因 + 深层原因 + 证据）
3. 影响范围（直接影响 + 间接影响）
4. 修复方案（优先最小修复，说明权衡）
5. 验证结果（构建/测试/手工验证）
6. 残余风险与后续建议

## ⚠️ 前置步骤（必须执行）

在开始修复 bug 之前，**必须先读取项目配置**：

1. **读取项目上下文**：
   - 使用 Read 工具读取 `.claude/project-context.md`
   - 确认技术栈、版本信息、开发规范

2. **读取 package.json**：
   - 确认当前项目的依赖版本

3. **理解用户描述**：
   - Bug 的表现症状是什么？
   - 在什么场景下出现？
   - 预期行为是什么？
   - 实际行为是什么？

只有完成以上步骤后，才能开始 bug 修复流程。

## 修复流程

### 阶段 1：问题定位（深入探索）

#### 1.1 理解问题表象

询问用户（如果描述不清晰）：
- "Bug 的具体表现是什么？"
- "在什么操作步骤下会出现？"
- "预期应该是什么样的？"
- "有报错信息吗？"
- "是否有复现步骤？"

#### 1.2 搜索相关代码

使用 Grep/Glob 工具搜索：
```markdown
1. **搜索关键组件/页面**
   - 根据用户描述找到相关文件
   - 使用 Glob 查找匹配的文件

2. **搜索关键函数**
   - 搜索可能相关的函数名
   - 搜索报错信息中的关键词

3. **搜索数据流**
   - 搜索状态管理相关代码
   - 搜索 API 调用
```

#### 1.3 深入追踪（找到根本原因）

**不要停留在表面现象，要追踪完整的调用链**：

```markdown
1. **找到触发点**
   - 用户操作触发了什么事件？
   - 哪个函数处理了这个事件？

2. **追踪调用链**
   - 使用 Grep 搜索函数调用关系
   - 绘制完整的调用链：A() → B() → C() → 问题点

3. **找到根本原因**
   - 为什么会出现这个问题？
   - 是逻辑错误、数据问题还是状态管理问题？
   - 触发条件是什么？

4. **记录证据**
   - 具体的代码位置（文件 + 行号）
   - 调用栈和执行流程
   - 触发条件
```

#### 1.4 寻找参考实现

搜索代码库中的类似场景：
- 其他地方是如何处理类似问题的？
- 是否有可以参考的最佳实践？
- 项目中是否有类似的工具函数？

### 阶段 2：影响分析（全面评估）

#### 2.1 直接影响范围

使用 Grep 搜索，找到所有相关的地方：
```bash
# 如果修改函数
grep -r "functionName" src/

# 如果修改组件
grep -r "ComponentName" src/

# 如果修改 Store
grep -r "useXXXStore" src/
```

回答以下问题：
- 这个文件/函数被哪些地方引用？
- 修复是否会影响其他功能？
- 是否需要同步修改其他文件？

#### 2.2 间接影响范围

- 数据流影响：状态变更会影响哪些组件？
- API 影响：接口变更会影响哪些调用方？
- 样式影响：CSS 修改会影响其他组件吗？
- 路由影响：URL 变更会影响跳转逻辑吗？

#### 2.3 风险评估

- 修复的复杂度：简单/中等/复杂
- 影响范围：局部/中等/全局
- 引入新 bug 的可能性：低/中/高
- 是否需要数据迁移：是/否

### 阶段 3：方案设计（治本方案）

#### 3.1 问题根因分析

生成根因分析报告：
```markdown
## 问题根因分析

**表面现象**：
[用户描述的症状]

**触发条件**：
1. [条件 1]
2. [条件 2]

**完整调用链**：
用户操作 → 事件处理 → 函数 A → 函数 B → 问题触发点

**根本原因**：
[深层次的原因，如：状态未正确更新、异步时序问题、数据结构不匹配等]

**证据**：
- 文件：`path/to/file.js:123`
- 代码：[关键代码片段]
```

#### 3.2 方案对比（治本 vs 治标）

如果有多种修复方式，对比各方案：

| 方案 | 类型 | 优点 | 缺点 | 风险 | 是否采用 |
|------|------|------|------|------|---------|
| 方案 A | 治标 | 改动小，快速 | 不解决根本问题 | 可能复发 | ❌ |
| 方案 B | 治本 | 从根源解决 | 改动稍大 | 可能影响其他功能 | ✅ 推荐 |
| 方案 C | 治本 | 彻底重构 | 工作量大 | 影响范围广 | ❌ 过度 |

**选择理由**：说明为什么选择某个方案

#### 3.3 修复方案设计

详细描述修复方案：
```markdown
## 修复方案

**修复思路**：
[简述修复的核心思路]

**需要修改的文件**：
1. `path/to/file1.js` - [修改内容]
2. `path/to/file2.js` - [修改内容]

**具体修改点**：
1. **文件 A：`path/to/file1.js:123`**
   - 原因：[为什么要改这里]
   - 修改：[具体修改内容]

2. **文件 B：`path/to/file2.js:456`**
   - 原因：[为什么要改这里]
   - 修改：[具体修改内容]

**参考实现**（如有）：
- 文件：`path/to/reference.js:789`
- 说明：[参考了什么模式]
```

#### 3.4 用户确认

向用户展示方案并确认：
```markdown
📋 **Bug 修复方案**

**问题根因**：[简述]

**修复思路**：[简述]

**影响范围**：
- 直接影响：[文件列表]
- 间接影响：[功能列表]
- 风险等级：🟢 低 / 🟡 中 / 🔴 高

**预计修改**：
- 修改文件数：[N 个]
- 代码行数：约 [M 行]

是否确认按此方案修复？
```

### 阶段 4：执行修复（严格执行）

#### 4.1 创建任务跟踪

使用 TodoWrite 工具创建任务列表：
```markdown
- [ ] 1. 修复文件 A 的问题点
- [ ] 2. 修复文件 B 的关联逻辑
- [ ] 3. 添加边界情况处理
- [ ] 4. 运行构建验证
- [ ] 5. 手动测试验证
```

#### 4.2 逐步修复

对于每个修改点：
1. 标记任务为 `in_progress`
2. 读取文件内容
3. 定位到具体位置
4. 执行修改（使用 Edit 工具）
5. 标记任务为 `completed`

#### 4.3 边界情况处理

考虑并处理边界情况：
- 空值/null/undefined 情况
- 异常情况的错误处理
- 用户输入验证
- 并发/竞态条件

#### 4.4 代码质量检查

- 是否遵循项目代码规范？
- 是否有代码重复？
- 是否有性能问题？
- 是否有安全隐患？

### 阶段 5：验证测试（确保修复）

#### 5.1 构建验证

运行构建命令：
```bash
npm run build
# 或
yarn build
```

检查是否有：
- 编译错误
- 类型错误
- 语法错误

#### 5.2 功能验证

手动测试：
```markdown
**测试场景 1：正常流程**
- 步骤：[操作步骤]
- 预期：[预期结果]
- 实际：[实际结果]
- 状态：✅ 通过 / ❌ 失败

**测试场景 2：边界情况**
- 步骤：[操作步骤]
- 预期：[预期结果]
- 实际：[实际结果]
- 状态：✅ 通过 / ❌ 失败

**测试场景 3：相关功能**
- 步骤：[测试其他相关功能]
- 预期：[不受影响]
- 实际：[实际结果]
- 状态：✅ 通过 / ❌ 失败
```

#### 5.3 回归测试

测试可能受影响的功能：
- 列出所有可能受影响的功能
- 逐一验证是否正常工作
- 记录测试结果

### 阶段 6：总结交付（完整报告）

生成修复报告：
```markdown
✅ **Bug 修复完成**

## 问题概述
- **问题描述**：[原始问题]
- **影响范围**：[受影响的功能]
- **严重程度**：🔴 严重 / 🟡 中等 / 🟢 轻微

## 根因分析
- **表面现象**：[症状]
- **根本原因**：[深层原因]
- **触发条件**：[何时出现]

## 修复方案
- **修复思路**：[核心思路]
- **修改文件**：
  1. `file1.js:123` - [修改内容]
  2. `file2.js:456` - [修改内容]

## 验证结果
- ✅ 构建通过
- ✅ 功能验证通过
- ✅ 回归测试通过

## 影响评估
- **直接影响**：[列出]
- **间接影响**：[列出]
- **引入风险**：[是否有新风险]

## 建议测试点
1. [测试点 1]
2. [测试点 2]
3. [测试点 3]
```

## 特殊场景处理

### 场景 1：紧急 Bug（热修复）

**特点**：线上问题，需要快速修复

**流程调整**：
1. 快速定位问题（可以先治标）
2. 提供临时修复方案
3. 验证后立即部署
4. 后续再进行治本的重构

**注意**：
- 记录技术债务
- 计划后续的治本方案

### 场景 2：复杂 Bug（多个原因）

**特点**：多个问题交织在一起

**处理方式**：
1. 拆解成多个子问题
2. 逐个分析根因
3. 设计综合修复方案
4. 分步骤修复

### 场景 3：历史遗留 Bug

**特点**：代码年代久远，缺少文档

**处理方式**：
1. 先理解历史代码的设计意图
2. 评估重构 vs 小改
3. 优先保证向后兼容
4. 充分测试

### 场景 4：间歇性 Bug

**特点**：难以复现，偶发性

**处理方式**：
1. 添加详细日志
2. 分析触发条件
3. 模拟复现场景
4. 修复后观察

## 检查清单

### 问题定位阶段

- [ ] 是否理解了问题表象？
- [ ] 是否找到了相关代码？
- [ ] 是否追踪了完整的调用链？
- [ ] 是否找到了根本原因？
- [ ] 是否有明确的证据？

### 影响分析阶段

- [ ] 是否搜索了所有引用？
- [ ] 是否评估了间接影响？
- [ ] 是否识别了潜在风险？
- [ ] 是否考虑了边界情况？

### 方案设计阶段

- [ ] 方案是否治本而非治标？
- [ ] 是否对比了多个方案？
- [ ] 是否有参考实现？
- [ ] 是否与用户确认了方案？

### 执行修复阶段

- [ ] 是否使用 TodoWrite 跟踪？
- [ ] 是否逐步完成并标记？
- [ ] 是否处理了边界情况？
- [ ] 是否遵循了代码规范？

### 验证测试阶段

- [ ] 是否通过了构建？
- [ ] 是否测试了正常流程？
- [ ] 是否测试了边界情况？
- [ ] 是否进行了回归测试？

### 总结交付阶段

- [ ] 是否生成了修复报告？
- [ ] 是否记录了根因分析？
- [ ] 是否列出了测试点？
- [ ] 是否评估了影响范围？

## 注意事项

### 核心原则（基于实战经验）

1. **探索 > 假设**
   - 不要基于假设下结论，要通过代码探索找到真相
   - 使用 Grep/Read 追踪完整的调用链
   - 找到问题的根本原因，而非表面现象

2. **治本 > 治标**
   - 要问"为什么会这样"，而非"怎么绕过去"
   - 优先选择从根源解决问题的方案
   - 避免临时性的 workaround（除非紧急情况）

3. **参考 > 创造**
   - 代码库中通常已有类似问题的解决方案
   - 优先使用项目中已有的模式和工具
   - 学习和遵循现有的最佳实践

4. **全面 > 片面**
   - 不要只修复看到的问题，要分析影响范围
   - 使用 Grep 搜索所有相关的代码
   - 考虑边界情况和异常场景

5. **验证 > 假定**
   - 修复后必须验证
   - 不要假定修复一定有效
   - 测试正常流程和边界情况

### 执行要求

- 🔍 **深入探索**（找到根本原因）
- 📊 **全面分析**（评估影响范围）
- 🎯 **治本修复**（从根源解决问题）
- 📋 **跟踪进度**（使用 TodoWrite）
- ✅ **充分验证**（测试多种场景）
- 📝 **完整报告**（记录修复过程）

### 禁止操作

- ❌ 不深入探索就开始修复
- ❌ 只治标不治本
- ❌ 不分析影响范围
- ❌ 修复后不验证
- ❌ 不使用 Todo 跟踪进度
- ❌ 引入新的 bug

## 示例用法

### 示例 1：UI 交互问题

**用户输入**：
```bash
/bug-fix

用户：下拉框选择后立即关闭了，无法保持打开状态
```

**你的执行流程**：

**阶段 1：问题定位**
1. 理解问题："下拉框选择后关闭"
2. 搜索下拉框组件（Grep 搜索 "Select" "Dropdown"）
3. 找到问题文件：`CollectorOutputs.jsx`
4. 追踪调用链：
   - onChange → handleSelectChange
   - handleSelectChange → props.replaceQuery
   - replaceQuery → openPageWithModuleHash
   - openPageWithModuleHash → history.push()
   - history.push() → 路由变化 → 组件重新渲染 → 下拉框关闭
5. 根本原因：URL 更新触发了路由变化，导致组件重新渲染

**阶段 2：影响分析**
1. 搜索 replaceQuery 的所有使用（Grep）
2. 发现多处使用，影响范围中等
3. 寻找参考：发现 `useUrlState` hook 使用 `window.history.replaceState()`

**阶段 3：方案设计**
```markdown
| 方案 | 类型 | 优点 | 缺点 | 是否采用 |
|------|------|------|------|---------|
| 控制下拉框状态 | 治标 | 改动小 | 不解决根本问题 | ❌ |
| 改用 replaceState | 治本 | 从根源解决 | 需要改调用方式 | ✅ |
```

**阶段 4：执行修复**
1. 创建 Todo：
   - [ ] 移除 onChange 中的 replaceQuery
   - [ ] 改用 window.history.replaceState
   - [ ] 测试验证
2. 修改 `CollectorOutputs.jsx`
3. 验证修复

**阶段 5：验证测试**
- ✅ 选择下拉框项，下拉框保持打开
- ✅ URL 正确更新
- ✅ 其他功能不受影响

**阶段 6：总结交付**
- 生成修复报告
- 说明根因和修复思路

### 示例 2：数据显示错误

**用户输入**：
```bash
/bug-fix

用户：告警列表中的"升级规则"显示为空，但数据库中有值
```

**你的执行流程**：

**阶段 1：问题定位**
1. 理解问题："升级规则显示为空"
2. 搜索告警列表组件
3. 找到渲染代码：`record.escalationRules.map(...)`
4. 检查数据结构
5. 发现：API 返回的字段名是 `escalation_items`，但代码中访问的是 `escalationRules`
6. 根本原因：字段名不匹配

**阶段 2：影响分析**
1. 搜索 `escalationRules` 的所有使用
2. 发现多处引用，需要统一修改
3. 检查 API 文档确认正确字段名

**阶段 3：方案设计**
```markdown
方案 A：修改前端字段名为 escalation_items
方案 B：后端改为返回 escalationRules
方案 C：添加数据转换层

选择方案 A：直接使用后端字段名，保持一致
```

**阶段 4：执行修复**
1. 批量替换 `escalationRules` → `escalation_items`
2. 检查所有引用点
3. 更新相关的类型定义（如有）

**阶段 5：验证测试**
- ✅ 升级规则正确显示
- ✅ 编辑功能正常
- ✅ 其他相关功能正常

**阶段 6：总结交付**
- 报告字段名不匹配问题
- 已统一为后端字段名

### 示例 3：性能问题

**用户输入**：
```bash
/bug-fix

用户：打开监控页面时，浏览器卡顿 5 秒以上
```

**你的执行流程**：

**阶段 1：问题定位**
1. 理解问题："页面加载卡顿"
2. 打开浏览器 Performance 分析
3. 发现：大量的重复渲染
4. 追踪原因：useEffect 缺少依赖项，导致无限循环
5. 根本原因：依赖项数组不完整

**阶段 2：影响分析**
1. 检查该组件的使用场景
2. 评估修复后的性能提升
3. 风险：低

**阶段 3：方案设计**
```markdown
方案：补充完整的依赖项数组
```

**阶段 4：执行修复**
1. 修复 useEffect 依赖项
2. 添加 useMemo/useCallback 优化

**阶段 5：验证测试**
- ✅ 页面加载流畅（< 1 秒）
- ✅ 功能正常
- ✅ 无重复渲染

**阶段 6：总结交付**
- 报告性能问题根因
- 已优化渲染性能

## 总结

Bug 修复是一个系统性的工程：
- 深入探索找到根本原因
- 全面分析评估影响范围
- 设计治本而非治标的方案
- 严格执行并充分验证
- 完整记录修复过程

记住：好的 bug 修复不仅要解决当前问题，还要避免类似问题再次发生！
