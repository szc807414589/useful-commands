# Claude 命令系统

一套专业的需求分析、产品规划、编码实施命令工具，基于 Markdown 文件的持久化记忆系统，帮助高效完成软件开发全流程。

## ✨ 核心特性

- 📝 **渐进式工作流程**：需求分析 → PRD 文档 → 编码计划 → 代码实施
- 🔗 **引用而非复制**：避免重复，使用文件引用保持信息一致性
- 📊 **进度可视化**：Phase 复选框 + 进度条，清晰追踪任务状态
- ⚠️ **自动检查点**：Hook 提醒机制，关键节点自动验证
- 💾 **持久化记忆**：progress.md、findings.md 记录完整执行过程
- 🎯 **智能引导**：每个命令输出后自动推荐下一步操作

## 🚀 快速开始

### 1. 初始化项目

```bash
# 在项目根目录运行
~/.claude-commands/init-project.sh

# 或指定项目目录
~/.claude-commands/init-project.sh /path/to/your/project
```

初始化后会创建：
- `.claude/project-context.md` - 项目配置（需手动填写）
- `.claude/commands/` - 命令软链接
- `.ai-configs/analysis/` - 需求分析报告
- `.ai-configs/prd/` - PRD 文档
- `.ai-configs/plan/` - 编码计划
- `.ai-configs/progress/` - 执行进度

### 2. 配置项目信息

编辑 `.claude/project-context.md`，填写：
- 项目名称和类型
- 技术栈版本（React、Ant Design、路由、状态管理等）
- 目录结构
- 开发规范
- API 规范

## 📋 核心命令

### 1. `/req-analyze` - 需求分析（推荐第一步）

**用途**：深度分析需求，探索代码库，评估可行性

**适用场景**：
- ✅ 需求不清晰，需要澄清
- ✅ 需要了解现有代码实现
- ✅ 需要评估技术可行性和工作量
- ✅ 需要识别风险和影响面

**执行流程**：
```
澄清需求（15%）
  ↓
探索代码库（40%）⚠️ 核心
  ├─ 搜索相关功能
  ├─ 找参考实现
  ├─ 实时记录发现 ⏱️ 新特性
  └─ 汇总探索结果
  ↓
影响面分析（25%）
  ├─ 直接影响
  ├─ 间接影响
  └─ 风险识别
  ↓
可行性评估（15%）
  ├─ 技术可行性
  ├─ 工作量评估
  └─ 优先级建议
  ↓
生成分析报告（5%）
```

**新特性**：
- ⏱️ **实时记录发现**：边探索边记录，带时间戳
- 📊 **智能引导**：根据复杂度推荐下一步
  - 复杂功能 → `/prd`
  - 中等功能 → `/create-plan`
  - 简单修复 → `/code-by-plan`

**输出**：
- `.ai-configs/analysis/YYYY/MM/[需求名称]-需求分析.md`
- 包含：完善需求、探索发现、影响分析、可行性评估

**示例**：
```bash
/req-analyze 告警历史导出 Excel 功能
/req-analyze 修复下拉框选择后立即关闭的问题
```

---

### 2. `/prd` - 生成产品需求文档

**用途**：基于需求分析生成产品需求文档（PRD）

**适用场景**：
- ✅ 需求分析完成，需要正式 PRD
- ✅ 复杂功能需要产品级文档
- ✅ 需要明确验收标准

**智能复用**：
- 如果有需求分析报告 → **引用而非复制**（节省 50-70% 时间）
- 如果无分析报告 → 轻量级需求理解（建议先运行 `/req-analyze`）

**关键原则**：
- ✅ 功能概要：1-2 行（最多 50 字）
- ✅ 技术方案：记录决策，引用探索发现
- ✅ 风险评估：只记录产品层面新增风险
- ❌ 不复制分析报告的详细内容

**输出**：
- `.ai-configs/prd/YYYY/MM/[功能名称].md`
- 包含：功能描述、技术方案、验收标准、风险评估、开发评估

**示例**：
```bash
/prd 告警历史导出 Excel 功能
```

---

### 3. `/create-plan` - 生成编码计划

**用途**：生成详细的编码实施计划

**适用场景**：
- ✅ PRD 已完成，准备编码
- ✅ 中等功能，功能清晰，有参考实现
- ✅ 需要详细的实施步骤

**智能复用**：
- 有需求分析报告 → **直接复用探索结果**（节省 60-80% 时间）
- 有 PRD（基于分析报告）→ 读取 PRD + 引用分析报告
- 有 PRD（无分析报告）→ 读取 PRD + 补充探索
- 无任何文档 → 建议先运行 `/req-analyze`

**关键原则**：
- ✅ 功能概要：3-5 行（最多 150 字）
- ✅ 参考实现：纯索引表（文件路径 + 行号）
- ✅ 实现步骤：**Phase 复选框格式** 🆕
- ✅ 风险评估：只记录实施层面风险
- ❌ 不复制代码片段
- ❌ 计划阶段不读取详细代码

**新特性**：
- ✅ **Phase 复选框格式**：
  ```
  Phase 1: 基础组件搭建
  - [ ] 步骤 1.1: 创建导出按钮组件
    - [ ] 子任务 1
    - [ ] 子任务 2
  Phase 1 进度: ⬜⬜⬜⬜ 0/4 (0%)

  总进度: 0/8 (0%)
  ```
- 📊 **自动化提示**：准备工作检查清单

**输出**：
- `.ai-configs/plan/YYYY/MM/[功能名称]-编码计划.md`
- 包含：功能概述、技术方案、实现步骤（Phase）、风险评估

**示例**：
```bash
/create-plan 告警历史导出 Excel 功能
/create-plan 修复下拉框选择后立即关闭的问题
```

---

### 4. `/code-by-plan` - 按计划编码

**用途**：严格按照编码计划执行代码实施

**适用场景**：
- ✅ 编码计划已完成
- ✅ 准备开始编码

**执行原则**：
- ⚠️ **严格遵循计划**：不偏离、不添加计划外功能
- ⚠️ **遵守约束条件**：用户明确的硬性要求
- ✅ **步步为营**：完成一步再进行下一步
- ✅ **透明沟通**：关键节点及时确认

**新特性**：
- 📝 **自动创建 progress.md**：
  - 执行日志（每步操作、涉及文件、结果、耗时）
  - 错误记录（时间、现象、根因、尝试方案、经验教训）
  - 测试结果（构建、单元测试、功能测试）
  - 待办事项
  - 进度统计

- ⚠️ **Hook 提醒机制**：
  - 🔵 **开始前检查**：是否读取计划、创建 progress.md、理解约束
  - 🟡 **执行中提醒**：每完成一步，检查是否更新进度、记录错误
  - 🔴 **完成后验证**：所有 Todo 完成、构建成功、progress.md 更新
  - 🟠 **错误发生时**：立即记录错误、分析根因、避免重复尝试

**输出**：
- 修改/创建的代码文件
- `.ai-configs/progress/YYYY/MM/[功能名称]-执行进度.md`

**示例**：
```bash
/code-by-plan
# 或指定计划文件
/code-by-plan .ai-configs/plan/2025/12/告警历史导出Excel功能-编码计划.md
```

---

## 🎯 推荐工作流程

### 流程 1：完整流程（复杂功能）

适用于：多文件、技术方案不明确、影响范围大

```bash
1️⃣ /req-analyze [需求描述]
   ↓ 10-30 分钟：深度探索、影响分析、可行性评估
   ✅ 输出：需求分析报告

2️⃣ /prd [功能描述]
   ↓ 10-20 分钟：引用分析报告，记录技术决策
   ✅ 输出：PRD 文档

3️⃣ /create-plan [功能描述]
   ↓ 30-40 分钟：引用分析报告+PRD，生成实施计划
   ✅ 输出：编码计划（Phase 复选框格式）

4️⃣ /code-by-plan
   ↓ 按计划执行：自动创建 progress.md，Hook 提醒
   ✅ 输出：代码 + 执行进度
```

**优势**：
- 📊 需求清晰，影响面不遗漏
- 🎯 决策有依据，可追溯
- ⏱️ 节省 60-80% 重复探索时间

---

### 流程 2：快速流程（中等功能）

适用于：功能清晰、有参考实现、单一模块

```bash
1️⃣ /req-analyze [需求描述]
   ↓ 15-20 分钟：快速探索、找参考
   ✅ 输出：需求分析报告

2️⃣ /create-plan [功能描述]
   ↓ 20-30 分钟：直接生成计划
   ✅ 输出：编码计划

3️⃣ /code-by-plan
   ↓ 按计划执行
   ✅ 输出：代码 + 执行进度
```

**优势**：
- ⚡ 跳过 PRD，直接编码
- 🎯 仍然有完整的分析和计划

---

### 流程 3：极简流程（简单修复）

适用于：单文件、根因明确、影响面小

```bash
1️⃣ /req-analyze [Bug 描述]
   ↓ 10-15 分钟：定位问题、找根因
   ✅ 输出：需求分析报告

2️⃣ /code-by-plan
   ↓ 直接编码修复
   ✅ 输出：代码 + 执行进度
```

**优势**：
- 🚀 最快速度
- 📝 仍然有根因分析和进度记录

---

## 📊 文档组织结构

```
.claude/
├── project-context.md          # 项目配置（手动编辑）
└── commands/                   # 命令软链接（.gitignore）

.ai-configs/
├── analysis/                   # 需求分析报告
│   └── YYYY/MM/
│       └── [需求名称]-需求分析.md
├── prd/                        # PRD 文档
│   └── YYYY/MM/
│       └── [功能名称].md
├── plan/                       # 编码计划
│   └── YYYY/MM/
│       └── [功能名称]-编码计划.md
└── progress/                   # 执行进度 🆕
    └── YYYY/MM/
        └── [功能名称]-执行进度.md
```

**三层引用结构**：
```
编码计划（如何实施）
  ↓ 引用
PRD 文档（技术决策和验收标准）
  ↓ 引用
需求分析报告（探索发现和技术细节）
```

---

## 🆕 新特性详解

### 1. 实时记录发现（req-analyze）

边探索边记录，带时间戳：
```markdown
⏱️ 10:30 找到相关模块：`src/monitor/alert/`
⏱️ 10:35 参考实现：`AlertHistory.jsx:234-289`
⏱️ 10:40 关键依赖：`xlsx@0.18.5`
```

**优势**：
- ✅ 避免遗忘重要发现
- ✅ 保持探索思路连贯
- ✅ 便于后续追溯过程

---

### 2. Phase 复选框格式（create-plan）

可视化进度追踪：
```markdown
Phase 1: 基础组件搭建
- [ ] 步骤 1.1: 创建导出按钮组件
  - 涉及文件：`src/components/ExportButton.jsx`
  - 具体任务：
    - [ ] 创建组件文件
    - [ ] 实现点击事件
    - [ ] 添加样式
  - 验收：按钮显示正常，点击触发事件
  - 预计时间：2 小时

Phase 1 进度: ⬜⬜⬜⬜ 0/4 (0%)

总进度: 0/8 (0%)
```

**优势**：
- 📊 进度一目了然
- ✅ 可独立验证每个步骤
- 🎯 时间评估更准确

---

### 3. Hook 提醒机制（code-by-plan）

自动检查点，防止遗漏：

**🔵 开始前检查（SessionStart）**：
```markdown
⚠️ 编码前检查清单
- [ ] 是否已读取编码计划？
- [ ] 是否已创建 progress.md 文件？
- [ ] 是否理解所有约束条件？
```

**🟡 执行中提醒**（每完成一步）：
```markdown
✅ 步骤 1 已完成

⚠️ 请确认以下操作：
- [ ] 是否更新了 progress.md 的执行日志？
- [ ] 是否标记了 Todo 状态为 completed？
- [ ] 是否记录了遇到的错误（如有）？
```

**🔴 完成后验证（Stop Hook）**：
```markdown
🎯 编码完成验证

⚠️ 最终检查清单：
- [ ] 所有 Todo 是否标记为 completed？
- [ ] 是否运行了构建测试（npm run build）？
- [ ] progress.md 是否已更新完整？
```

**🟠 错误发生时（Error Hook）**：
```markdown
❌ 检测到错误

⚠️ 错误处理流程：
1. 立即停止当前操作
2. 在 progress.md 中记录错误
3. 分析是否需要调整计划
4. 记录经验教训

**不要重复相同的错误尝试！**
```

---

### 4. progress.md 执行进度（code-by-plan）

完整记录执行过程：

```markdown
# 告警历史导出Excel功能 - 执行进度

**开始时间**：2025-12-15 10:30
**编码计划**：`.ai-configs/plan/2025/12/告警历史导出Excel功能-编码计划.md`

## 执行日志

### Session 1 (2025-12-15 10:30 - 11:45)

✅ **步骤 1**: 安装 xlsx 库
- 操作：npm install xlsx@0.18.5
- 结果：安装成功
- 耗时：2 分钟

🔄 **步骤 2**: 创建导出工具函数（进行中）
- 操作：创建 src/utils/exportExcel.js
- 当前状态：正在实现数据转换逻辑

## 错误记录

### Error 1: xlsx 库版本冲突
- **时间**：2025-12-15 10:32
- **阶段**：步骤 1
- **现象**：npm install 报错
- **根因**：package-lock.json 中有旧版本锁定
- **尝试方案**：
  - ❌ 方案 1：直接 npm install → 失败：版本冲突
  - ✅ 方案 2：删除 package-lock.json 重新安装 → 成功
- **经验教训**：遇到版本冲突先检查 package-lock.json

## 进度统计

- **总步骤数**：5
- **已完成**：1
- **进行中**：1
- **待执行**：3
- **完成度**：20%
```

---

### 5. 智能引导（全部命令）

每个命令完成后自动推荐下一步：

**req-analyze 完成后**：
```bash
# 根据复杂度智能推荐
复杂功能 → /prd [需求描述]
中等功能 → /create-plan [需求描述]
简单修复 → /code-by-plan
```

**prd 完成后**：
```bash
/create-plan [功能描述]  # 生成编码计划（30-40分钟）
```

**create-plan 完成后**：
```bash
/code-by-plan  # 按计划开始编码

准备工作：
- ✅ 确认已理解所有约束条件
- ✅ 确认技术方案可行
- ✅ 建议先与团队评审计划
```

**code-by-plan 完成后**：
```bash
# 手动测试
npm run build

# 提交代码
git commit -m "feat: xxx"
git push

# 创建 PR
gh pr create
```

---

## 🔧 其他命令

### `/update-prd` - 更新 PRD 文档

基于新的需求分析更新现有 PRD

```bash
/update-prd
```

---

### `/update-plan` - 更新编码计划

基于新的 PRD 或需求变更更新编码计划

```bash
/update-plan
```

---

### `/bug-fix` - Bug 修复

快速修复 Bug 的专用流程

```bash
/bug-fix [Bug 描述]
```

---

### `/review` - 代码审查

对代码进行审查和质量检查

```bash
/review
```

---

## 💡 最佳实践

### 1. 优先使用需求分析

**建议**：任何功能开发前先运行 `/req-analyze`

**理由**：
- ✅ 避免需求遗漏
- ✅ 提前发现风险
- ✅ 后续命令节省 60-80% 时间

---

### 2. 充分利用引用机制

**原则**：引用 > 复制

**好处**：
- ✅ 信息单一来源
- ✅ 维护成本低
- ✅ 文档精简 50-60%

---

### 3. 严格遵循计划

**原则**：在 `code-by-plan` 阶段不偏离计划

**如需调整**：
1. 停止当前工作
2. 说明原因
3. 与用户确认
4. 更新计划文档

---

### 4. 重视进度记录

**必须做**：
- ✅ 实时更新 progress.md
- ✅ 记录所有错误（避免重复）
- ✅ 记录经验教训

---

### 5. 利用 Hook 机制

**自动检查点**：
- 开始前检查：确保准备充分
- 执行中提醒：避免遗漏步骤
- 完成后验证：确保质量
- 错误处理：系统化记录

---

## 📈 效率对比

### 传统方式 vs 命令系统

| 阶段 | 传统方式 | 命令系统 | 节省时间 |
|------|---------|---------|---------|
| 需求理解 | 30-60 分钟 | 15-30 分钟（澄清） | 50% |
| 代码探索 | 60-120 分钟 | 20-40 分钟（实时记录） | 70% |
| 编写 PRD | 60-90 分钟 | 10-20 分钟（引用） | 75% |
| 编码计划 | 90-120 分钟 | 30-40 分钟（引用） | 65% |
| 代码实施 | 不确定 | 可预估（Phase 计划） | 进度可控 |
| **总计** | **240-390 分钟** | **75-130 分钟** | **60-70%** |

**关键优势**：
- 📊 **可追溯性**：完整的决策链路
- 🎯 **可预测性**：Phase 计划，进度可控
- 💾 **可复用性**：文档引用，避免重复
- ⚡ **高效率**：节省 60-70% 时间

---

## 🤝 贡献

本命令系统设计参考了：
- [planning-with-files](https://github.com/OthmanAdi/planning-with-files) - 文件系统作为持久化记忆的理念
- Manus-style planning - 多文件协作模式

---

## 📄 许可

MIT

---

## 📞 反馈

如有问题或建议，欢迎提 Issue 或 PR。
